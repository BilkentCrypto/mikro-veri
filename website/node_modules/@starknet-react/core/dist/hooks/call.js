"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useStarknetCall = void 0;
const react_query_1 = require("@tanstack/react-query");
const react_1 = require("react");
const providers_1 = require("../providers");
const invalidate_1 = require("./invalidate");
/**
 * Hook to perform a read-only contract call.
 *
 * @remarks
 *
 * The hook only performs a call if the target `contract`,
 * `method`, and `args` are not undefined.
 *
 * @example
 * This example shows how to fetch the user ERC-20 balance.
 * ```tsx
 * function Component() {
 *   const { contract } = useContract({
 *     address: ethAddress,
 *     abi: compiledErc20.abi
 *   })
 *   const { address } = useAccount()
 *   const { data, loading, error, refresh } = useStarknetCall({
 *     contract,
 *     method: 'balanceOf',
 *     args: [address],
 *     options: {
 *       watch: false
 *     }
 *   })
 *
 *   if (loading) return <span>Loading...</span>
 *   if (error) return <span>Error: {error}</span>
 *
 *   return (
 *     <div>
 *       <button onClick={refresh}>Refresh</button>
 *       <p>Balance: {JSON.stringify(data)}</p>
 *     </div>
 *   )
 * }
 * ```
 */
function useStarknetCall({ contract, method, args, options, }) {
    const { library } = (0, providers_1.useStarknet)();
    const blockIdentifier = options?.blockIdentifier || 'pending';
    const queryKey_ = (0, react_1.useMemo)(() => queryKey({ library, args: { contract, method, args, blockIdentifier } }), [library, contract, method, args, blockIdentifier]);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const { data, isLoading, isError, refetch, isRefetching } = (0, react_query_1.useQuery)(queryKey_, readContract({ args: { contract, method, args, blockIdentifier } }));
    (0, invalidate_1.useInvalidateOnBlock)({ enabled: options?.watch, queryKey: queryKey_ });
    return {
        data,
        loading: isLoading,
        refreshing: isRefetching,
        refresh: refetch,
        error: isError ? 'error performing call' : undefined,
    };
}
exports.useStarknetCall = useStarknetCall;
function readContract({ args }) {
    return async () => {
        if (!args.args || !args.contract || !args.method)
            return null;
        const call = args.contract && args.method && args.contract[args.method];
        if (!call)
            return null;
        return await call(...args.args, {
            blockIdentifier: args.blockIdentifier,
        });
    };
}
function queryKey({ library, args }) {
    const { contract, method, args: callArgs, blockIdentifier } = args;
    return [
        {
            entity: 'readContract',
            chainId: library.chainId,
            contract: contract?.address,
            method,
            args: callArgs,
            blockIdentifier,
        },
    ];
}
//# sourceMappingURL=call.js.map