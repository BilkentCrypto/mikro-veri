{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar notifyManager = require('./notifyManager.js');\nvar mutation = require('./mutation.js');\nvar utils = require('./utils.js');\nvar subscribable = require('./subscribable.js');\n\n// CLASS\nclass MutationCache extends subscribable.Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.mutations = [];\n    this.mutationId = 0;\n  }\n  build(client, options, state) {\n    const mutation$1 = new mutation.Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : undefined,\n      meta: options.meta\n    });\n    this.add(mutation$1);\n    return mutation$1;\n  }\n  add(mutation) {\n    this.mutations.push(mutation);\n    this.notify({\n      type: 'added',\n      mutation\n    });\n  }\n  remove(mutation) {\n    this.mutations = this.mutations.filter(x => x !== mutation);\n    this.notify({\n      type: 'removed',\n      mutation\n    });\n  }\n  clear() {\n    notifyManager.notifyManager.batch(() => {\n      this.mutations.forEach(mutation => {\n        this.remove(mutation);\n      });\n    });\n  }\n  getAll() {\n    return this.mutations;\n  }\n  find(filters) {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n    return this.mutations.find(mutation => utils.matchMutation(filters, mutation));\n  }\n  findAll(filters) {\n    return this.mutations.filter(mutation => utils.matchMutation(filters, mutation));\n  }\n  notify(event) {\n    notifyManager.notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n  resumePausedMutations() {\n    const pausedMutations = this.mutations.filter(x => x.state.isPaused);\n    return notifyManager.notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(utils.noop)), Promise.resolve()));\n  }\n}\nexports.MutationCache = MutationCache;","map":{"version":3,"mappings":";;;;;;;;;;AA0EA;AAEO,MAAMA,aAAN,SAA4BC,yBAA5B,CAAgE;EAMrEC,WAAW,CAACC,MAAD,EAA+B;IACxC;IACA,KAAKA,MAAL,GAAcA,MAAM,IAAI,EAAxB;IACA,IAAKC,UAAL,GAAiB,EAAjB;IACA,IAAKC,WAAL,GAAkB,CAAlB;EACD;EAEDC,KAAK,CACHC,MADG,EAEHC,OAFG,EAGHC,KAHG,EAI4C;IAC/C,MAAMC,UAAQ,GAAG,IAAIC,iBAAJ,CAAa;MAC5BC,aAAa,EAAE,IADa;MAE5BC,MAAM,EAAEN,MAAM,CAACO,SAAP,EAFoB;MAG5BT,UAAU,EAAE,EAAE,KAAKA,UAHS;MAI5BG,OAAO,EAAED,MAAM,CAACQ,sBAAP,CAA8BP,OAA9B,CAJmB;MAK5BC,KAL4B;MAM5BO,cAAc,EAAER,OAAO,CAACS,WAAR,GACZV,MAAM,CAACW,mBAAP,CAA2BV,OAAO,CAACS,WAAnC,CADY,GAEZE,SARwB;MAS5BC,IAAI,EAAEZ,OAAO,CAACY;IATc,CAAb,CAAjB;IAYA,IAAKC,IAAL,CAASX,UAAT;IAEA,OAAOA,UAAP;EACD;EAEDW,GAAG,CAACX,QAAD,EAA+C;IAChD,KAAKN,SAAL,CAAekB,IAAf,CAAoBZ,QAApB;IACA,KAAKa,MAAL,CAAY;MAAEC,IAAI,EAAE,OAAR;MAAiBd;KAA7B;EACD;EAEDe,MAAM,CAACf,QAAD,EAA+C;IACnD,KAAKN,SAAL,GAAiB,IAAKA,UAAL,CAAesB,MAAf,CAAuBC,CAAD,IAAOA,CAAC,KAAKjB,QAAnC,CAAjB;IACA,KAAKa,MAAL,CAAY;MAAEC,IAAI,EAAE,SAAR;MAAmBd;KAA/B;EACD;EAEDkB,KAAK,GAAS;IACZC,2BAAa,CAACC,KAAd,CAAoB,MAAM;MACxB,KAAK1B,SAAL,CAAe2B,OAAf,CAAwBrB,QAAD,IAAc;QACnC,IAAKe,OAAL,CAAYf,QAAZ;OADF;KADF;EAKD;EAEDsB,MAAM,GAAe;IACnB,OAAO,KAAK5B,SAAZ;EACD;EAED6B,IAAI,CACFC,OADE,EAEyD;IAC3D,IAAI,OAAOA,OAAO,CAACC,KAAf,KAAyB,WAA7B,EAA0C;MACxCD,OAAO,CAACC,KAAR,GAAgB,IAAhB;IACD;IAED,OAAO,IAAK/B,UAAL,CAAe6B,IAAf,CAAqBvB,QAAD,IAAc0B,mBAAa,CAACF,OAAD,EAAUxB,QAAV,CAA/C,CAAP;EACD;EAED2B,OAAO,CAACH,OAAD,EAAuC;IAC5C,OAAO,IAAK9B,UAAL,CAAesB,MAAf,CAAuBhB,QAAD,IAAc0B,mBAAa,CAACF,OAAD,EAAUxB,QAAV,CAAjD,CAAP;EACD;EAEDa,MAAM,CAACe,KAAD,EAAkC;IACtCT,2BAAa,CAACC,KAAd,CAAoB,MAAM;MACxB,KAAKS,SAAL,CAAeR,OAAf,CAAwBS,QAAD,IAAc;QACnCA,QAAQ,CAACF,KAAD,CAAR;OADF;KADF;EAKD;EAEDG,qBAAqB,GAAkB;IACrC,MAAMC,eAAe,GAAG,IAAKtC,UAAL,CAAesB,MAAf,CAAuBC,CAAD,IAAOA,CAAC,CAAClB,KAAF,CAAQkC,QAArC,CAAxB;IACA,OAAOd,2BAAa,CAACC,KAAd,CAAoB,MACzBY,eAAe,CAACE,MAAhB,CACE,CAACC,OAAD,EAAUnC,QAAV,KACEmC,OAAO,CAACC,IAAR,CAAa,MAAMpC,QAAQ,CAACqC,QAAT,GAAoBC,KAApB,CAA0BC,UAA1B,CAAnB,CAFJ,EAGEC,OAAO,CAACC,OAAR,EAHF,CADK,CAAP;EAOD;AAxFoE","names":["MutationCache","Subscribable","constructor","config","mutations","mutationId","build","client","options","state","mutation","Mutation","mutationCache","logger","getLogger","defaultMutationOptions","defaultOptions","mutationKey","getMutationDefaults","undefined","meta","add","push","notify","type","remove","filter","x","clear","notifyManager","batch","forEach","getAll","find","filters","exact","matchMutation","findAll","event","listeners","listener","resumePausedMutations","pausedMutations","isPaused","reduce","promise","then","continue","catch","noop","Promise","resolve"],"sources":["/Users/utkukoca/Desktop/Project-Challange/my-project/node_modules/@tanstack/query-core/src/mutationCache.ts"],"sourcesContent":["import type { MutationObserver } from './mutationObserver'\nimport type { MutationOptions } from './types'\nimport type { QueryClient } from './queryClient'\nimport { notifyManager } from './notifyManager'\nimport type { Action, MutationState } from './mutation'\nimport { Mutation } from './mutation'\nimport type { MutationFilters } from './utils'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\ntype MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  config: MutationCacheConfig\n\n  private mutations: Mutation<any, any, any, any>[]\n  private mutationId: number\n\n  constructor(config?: MutationCacheConfig) {\n    super()\n    this.config = config || {}\n    this.mutations = []\n    this.mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>,\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey\n        ? client.getMutationDefaults(options.mutationKey)\n        : undefined,\n      meta: options.meta,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.mutations.push(mutation)\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    this.mutations = this.mutations.filter((x) => x !== mutation)\n    this.notify({ type: 'removed', mutation })\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.mutations.forEach((mutation) => {\n        this.remove(mutation)\n      })\n    })\n  }\n\n  getAll(): Mutation[] {\n    return this.mutations\n  }\n\n  find<TData = unknown, TError = unknown, TVariables = any, TContext = unknown>(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true\n    }\n\n    return this.mutations.find((mutation) => matchMutation(filters, mutation))\n  }\n\n  findAll(filters: MutationFilters): Mutation[] {\n    return this.mutations.filter((mutation) => matchMutation(filters, mutation))\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<void> {\n    const pausedMutations = this.mutations.filter((x) => x.state.isPaused)\n    return notifyManager.batch(() =>\n      pausedMutations.reduce(\n        (promise, mutation) =>\n          promise.then(() => mutation.continue().catch(noop)),\n        Promise.resolve(),\n      ),\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}