{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar React = require('react');\nvar useSyncExternalStore = require('./useSyncExternalStore');\nvar queryCore = require('@tanstack/query-core');\nvar QueryClientProvider = require('./QueryClientProvider.js');\nvar isRestoring = require('./isRestoring.js');\nvar QueryErrorResetBoundary = require('./QueryErrorResetBoundary.js');\nvar errorBoundaryUtils = require('./errorBoundaryUtils.js');\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\n// - `context` is omitted as it is passed as a root-level option to `useQueries` instead.\n\nfunction useQueries(_ref) {\n  let {\n    queries,\n    context\n  } = _ref;\n  const queryClient = QueryClientProvider.useQueryClient({\n    context\n  });\n  const isRestoring$1 = isRestoring.useIsRestoring();\n  const defaultedQueries = React__namespace.useMemo(() => queries.map(options => {\n    const defaultedOptions = queryClient.defaultQueryOptions(options); // Make sure the results are already in fetching state before subscribing or updating options\n\n    defaultedOptions._optimisticResults = isRestoring$1 ? 'isRestoring' : 'optimistic';\n    return defaultedOptions;\n  }), [queries, queryClient, isRestoring$1]);\n  const [observer] = React__namespace.useState(() => new queryCore.QueriesObserver(queryClient, defaultedQueries));\n  const result = observer.getOptimisticResult(defaultedQueries);\n  useSyncExternalStore.useSyncExternalStore(React__namespace.useCallback(onStoreChange => isRestoring$1 ? () => undefined : observer.subscribe(queryCore.notifyManager.batchCalls(onStoreChange)), [observer, isRestoring$1]), () => observer.getCurrentResult(), () => observer.getCurrentResult());\n  React__namespace.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, {\n      listeners: false\n    });\n  }, [defaultedQueries, observer]);\n  const errorResetBoundary = QueryErrorResetBoundary.useQueryErrorResetBoundary();\n  defaultedQueries.forEach(query => {\n    errorBoundaryUtils.ensurePreventErrorBoundaryRetry(query, errorResetBoundary);\n  });\n  errorBoundaryUtils.useClearResetErrorBoundary(errorResetBoundary);\n  const firstSingleResultWhichShouldThrow = result.find((singleResult, index) => {\n    var _defaultedQueries$ind, _defaultedQueries$ind2;\n    return errorBoundaryUtils.getHasError({\n      result: singleResult,\n      errorResetBoundary,\n      useErrorBoundary: (_defaultedQueries$ind = (_defaultedQueries$ind2 = defaultedQueries[index]) == null ? void 0 : _defaultedQueries$ind2.useErrorBoundary) != null ? _defaultedQueries$ind : false,\n      query: observer.getQueries()[index]\n    });\n  });\n  if (firstSingleResultWhichShouldThrow != null && firstSingleResultWhichShouldThrow.error) {\n    throw firstSingleResultWhichShouldThrow.error;\n  }\n  return result;\n}\nexports.useQueries = useQueries;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;;AA+HO,SAASA,UAAT,OAMe;EAAA,IANsB;IAC1CC,OAD0C;IAE1CC;EAF0C,CAArC;EAOL,MAAMC,WAAW,GAAGC,kCAAc,CAAC;IAAEF;EAAF,CAAD,CAAlC;EACA,MAAMG,aAAW,GAAGC,0BAAc,EAAlC;EAEA,MAAMC,gBAAgB,GAAGC,gBAAK,CAACC,OAAN,CACvB,MACER,OAAO,CAACS,GAAR,CAAaC,OAAD,IAAa;IACvB,MAAMC,gBAAgB,GAAGT,WAAW,CAACU,mBAAZ,CAAgCF,OAAhC,CAAzB,CADuB;;IAIvBC,gBAAgB,CAACE,kBAAjB,GAAsCT,aAAW,GAC7C,aAD6C,GAE7C,YAFJ;IAIA,OAAOO,gBAAP;EARF,EAFqB,EAYvB,CAACX,OAAD,EAAUE,WAAV,EAAuBE,aAAvB,CAZuB,CAAzB;EAeA,MAAM,CAACU,QAAD,CAAaP,mBAAK,CAACQ,QAAN,CACjB,MAAM,IAAIC,yBAAJ,CAAoBd,WAApB,EAAiCI,gBAAjC,CADW,CAAnB;EAIA,MAAMW,MAAM,GAAGH,QAAQ,CAACI,mBAAT,CAA6BZ,gBAA7B,CAAf;EAEAa,yCAAoB,CAClBZ,gBAAK,CAACa,WAAN,CACGC,aAAD,IACEjB,aAAW,GACP,MAAMkB,SADC,GAEPR,QAAQ,CAACS,SAAT,CAAmBC,SAAa,eAACC,UAAd,CAAyBJ,aAAzB,CAAnB,CAJR,EAKE,CAACP,QAAD,EAAWV,aAAX,CALF,CADkB,EAQlB,MAAMU,QAAQ,CAACY,gBAAT,EARY,EASlB,MAAMZ,QAAQ,CAACY,gBAAT,EATY,CAApB;EAYAnB,gBAAK,CAACoB,SAAN,CAAgB,MAAM;IACpB;IACA;IACAb,QAAQ,CAACc,UAAT,CAAoBtB,gBAApB,EAAsC;MAAEuB,SAAS,EAAE;KAAnD;EACD,CAJD,EAIG,CAACvB,gBAAD,EAAmBQ,QAAnB,CAJH;EAMA,MAAMgB,kBAAkB,GAAGC,kDAA0B,EAArD;EAEAzB,gBAAgB,CAAC0B,OAAjB,CAA0BC,KAAD,IAAW;IAClCC,kDAA+B,CAACD,KAAD,EAAQH,kBAAR,CAA/B;GADF;EAIAK,kBAA0B,4BAACL,kBAAD,CAA1B;EAEA,MAAMM,iCAAiC,GAAGnB,MAAM,CAACoB,IAAP,CAAY,CAACC,YAAD,EAAeC,KAAf;IAAA;IAAA,OACpDC,8BAAW,CAAC;MACVvB,MAAM,EAAEqB,YADE;MAEVR,kBAFU;MAGVW,gBAAgB,qDAAEnC,gBAAgB,CAACiC,KAAD,CAAlB,KAAE,uCAAyBE,gBAA3B,oCAA+C,KAHrD;MAIVR,KAAK,EAAEnB,QAAQ,CAAC4B,UAAT,GAAsBH,KAAtB;IAJG,CAAD,CADyC;EAAA,CAAZ,CAA1C;EASA,IAAIH,iCAAJ,YAAIA,iCAAiC,CAAEO,KAAvC,EAA8C;IAC5C,MAAMP,iCAAiC,CAACO,KAAxC;EACD;EAED,OAAO1B,MAAP;AACD","names":["useQueries","queries","context","queryClient","useQueryClient","isRestoring","useIsRestoring","defaultedQueries","React","useMemo","map","options","defaultedOptions","defaultQueryOptions","_optimisticResults","observer","useState","QueriesObserver","result","getOptimisticResult","useSyncExternalStore","useCallback","onStoreChange","undefined","subscribe","notifyManager","batchCalls","getCurrentResult","useEffect","setQueries","listeners","errorResetBoundary","useQueryErrorResetBoundary","forEach","query","ensurePreventErrorBoundaryRetry","useClearResetErrorBoundary","firstSingleResultWhichShouldThrow","find","singleResult","index","getHasError","useErrorBoundary","getQueries","error"],"sources":["/Users/utkukoca/Desktop/Project-Challange/my-project/node_modules/@tanstack/react-query/src/useQueries.ts"],"sourcesContent":["import * as React from 'react'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport type { QueryKey, QueryFunction } from '@tanstack/query-core'\nimport { notifyManager, QueriesObserver } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type { UseQueryOptions, UseQueryResult } from './types'\nimport { useIsRestoring } from './isRestoring'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// - `context` is omitted as it is passed as a root-level option to `useQueries` instead.\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>, 'context'>\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptionsForUseQueries<\n        TQueryFnData,\n        unknown,\n        TQueryFnData,\n        TQueryKey\n      >\n    : // Fallback\n      UseQueryOptionsForUseQueries\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? UseQueryResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryResult<TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? UseQueryResult<TQueryFnData>\n    : // Fallback\n      UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptionsForUseQueries[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptionsForUseQueries[]\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    UseQueryResult<unknown extends TData ? TQueryFnData : TData, TError>[]\n  : // Fallback\n    UseQueryResult[]\n\nexport function useQueries<T extends any[]>({\n  queries,\n  context,\n}: {\n  queries: readonly [...QueriesOptions<T>]\n  context?: UseQueryOptions['context']\n}): QueriesResults<T> {\n  const queryClient = useQueryClient({ context })\n  const isRestoring = useIsRestoring()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((options) => {\n        const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, queryClient, isRestoring],\n  )\n\n  const [observer] = React.useState(\n    () => new QueriesObserver(queryClient, defaultedQueries),\n  )\n\n  const result = observer.getOptimisticResult(defaultedQueries)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, { listeners: false })\n  }, [defaultedQueries, observer])\n\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  defaultedQueries.forEach((query) => {\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const firstSingleResultWhichShouldThrow = result.find((singleResult, index) =>\n    getHasError({\n      result: singleResult,\n      errorResetBoundary,\n      useErrorBoundary: defaultedQueries[index]?.useErrorBoundary ?? false,\n      query: observer.getQueries()[index]!,\n    }),\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return result as QueriesResults<T>\n}\n"]},"metadata":{},"sourceType":"script"}